{"ast":null,"code":"import create from \"zustand\";\nconst initialState = {\n  course: {\n    name: \"\",\n    description: \"\",\n    modules: []\n  }\n};\nconst useCourseStore = create(set => ({\n  // State\n  course: initialState.course,\n  selectedOption: \"quiz\",\n  // Actions\n  setCourse: newCourse => set({\n    course: newCourse\n  }),\n  handleChangeSelect: (e, moduleIndex) => {\n    const {\n      value\n    } = e.target;\n    set(state => ({\n      selectedOption: value,\n      course: { ...state.course,\n        modules: state.course.modules.map((module, idx) => {\n          if (idx === moduleIndex) {\n            let updatedContents = [];\n\n            if (module.content) {\n              updatedContents = module.content.map(content => {\n                if (content.type === value) {\n                  if (value === \"video\") {\n                    return {\n                      type: \"video\",\n                      url: \"\"\n                    };\n                  } else if (value === \"text\") {\n                    return {\n                      type: \"text\",\n                      text: \"\"\n                    };\n                  } else if (value === \"quiz\") {\n                    const quizData = {\n                      question: \"\",\n                      answers: [\"\", \"\", \"\", \"\"],\n                      correctAnswer: \"\"\n                    };\n                    return {\n                      type: \"quiz\",\n                      question: [quizData]\n                    };\n                  }\n                }\n\n                return content;\n              });\n            }\n\n            return { ...module,\n              content: updatedContents\n            };\n          }\n\n          return module;\n        })\n      }\n    }));\n  },\n  handleAddModule: () => {\n    set(state => {\n      const newModule = {\n        name: \"\",\n        content: []\n      };\n      return {\n        course: {\n          modules: [...state.course.modules, newModule]\n        }\n      };\n    });\n  },\n  handleModuleChange: (index, fieldName, fieldValue) => {\n    set(state => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === index) {\n          return { ...module,\n            [fieldName]: fieldValue\n          };\n        }\n\n        return module;\n      });\n      return {\n        course: {\n          modules: updatedModules\n        }\n      };\n    });\n  },\n  handleDeleteContent: (moduleIndex, contentIndex) => {\n    set(state => ({\n      course: { ...state.course,\n        modules: state.course.modules.map((module, idx) => {\n          if (idx === moduleIndex) {\n            const updatedContents = module.content.filter((content, cIdx) => cIdx !== contentIndex);\n            return { ...module,\n              content: updatedContents\n            };\n          }\n\n          return module;\n        })\n      }\n    }));\n  },\n  handleAddContent: moduleIndex => {\n    set(state => ({\n      course: { ...state.course,\n        modules: state.course.modules.map((module, idx) => {\n          if (idx === moduleIndex) {\n            let updatedContents = [...(module.content || [])]; // Ensure content array exists or initialize as empty array\n\n            if (state.selectedOption === \"video\") {\n              updatedContents.push({\n                type: \"video\",\n                url: \"\"\n              });\n            } else if (state.selectedOption === \"text\") {\n              updatedContents.push({\n                type: \"text\",\n                text: \"\"\n              });\n            } else if (state.selectedOption === \"quiz\") {\n              // Check if there's already a quiz content, if not, add it\n              const existingQuizContentIndex = updatedContents.findIndex(content => content.type === \"quiz\");\n\n              if (existingQuizContentIndex === -1) {\n                const quizData = {\n                  question: \"\",\n                  answers: [\"\", \"\", \"\", \"\"],\n                  correctAnswer: \"\"\n                };\n                updatedContents.push({\n                  type: \"quiz\",\n                  question: [quizData]\n                });\n              }\n            }\n\n            return { ...module,\n              content: updatedContents\n            };\n          }\n\n          return module;\n        })\n      }\n    }));\n  },\n  handleDeleteModule: moduleIndex => {\n    set(state => {\n      const updatedModules = state.course.modules.filter((module, idx) => idx !== moduleIndex);\n      return {\n        course: {\n          modules: updatedModules\n        }\n      };\n    });\n  },\n  handleQuestion: (moduleIndex, questionIndex, key, value) => {\n    set(state => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === moduleIndex && module.content[questionIndex].type === \"quiz\") {\n          const updatedQuestion = { ...module.content[questionIndex]\n          };\n          updatedQuestion.question = value;\n          return { ...module,\n            content: module.content.map((content, cIdx) => cIdx === questionIndex ? updatedQuestion : content)\n          };\n        }\n\n        return module;\n      });\n      return { ...state,\n        course: { ...state.course,\n          modules: updatedModules\n        }\n      };\n    });\n  },\n  handleAnswerChange: (moduleIndex, questionIndex, answerIndex, value) => {\n    set(state => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === moduleIndex && module.content[questionIndex].type === \"quiz\") {\n          const updatedQuestion = { ...module.content[questionIndex]\n          };\n          updatedQuestion.answers[answerIndex] = value;\n          return { ...module,\n            content: module.content.map((content, cIdx) => cIdx === questionIndex ? updatedQuestion : content)\n          };\n        }\n\n        return module;\n      });\n      return { ...state,\n        course: { ...state.course,\n          modules: updatedModules\n        }\n      };\n    });\n  },\n  handleCorrectAnswerChange: (moduleIndex, questionIndex, value) => {\n    set(state => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === moduleIndex && module.content[questionIndex].type === \"quiz\") {\n          const updatedQuestion = { ...module.content[questionIndex]\n          };\n          updatedQuestion.correctAnswer = value;\n          return { ...module,\n            content: module.content.map((content, cIdx) => cIdx === questionIndex ? updatedQuestion : content)\n          };\n        }\n\n        return module;\n      });\n      return { ...state,\n        course: { ...state.course,\n          modules: updatedModules\n        }\n      };\n    });\n  },\n  handleAddQuestion: moduleIndex => {\n    set(state => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === moduleIndex) {\n          const updatedContent = [...(module.content || [])];\n          const existingQuizIndex = updatedContent.findIndex(content => content.type === \"quiz\");\n\n          if (existingQuizIndex !== -1) {\n            const updatedQuestion = {\n              question: \"\",\n              answers: [\"\", \"\", \"\", \"\"],\n              correctAnswer: \"\"\n            };\n            updatedContent[existingQuizIndex].question.push(updatedQuestion);\n          }\n\n          return { ...module,\n            content: updatedContent\n          };\n        }\n\n        return module;\n      });\n      return { ...state,\n        course: { ...state.course,\n          modules: updatedModules\n        }\n      };\n    });\n  },\n  handleDeleteQuestion: (moduleIndex, questionIndex) => {\n    set(state => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === moduleIndex && module.content[questionIndex].type === \"quiz\") {\n          const updatedContent = [...module.content];\n          updatedContent[questionIndex].question.splice(questionIndex, 1);\n          return { ...module,\n            content: updatedContent\n          };\n        }\n\n        return module;\n      });\n      return { ...state,\n        course: { ...state.course,\n          modules: updatedModules\n        }\n      };\n    });\n  },\n  handleContentChange: (moduleIndex, contentIndex, fieldName, fieldValue) => {\n    set(state => {\n      const updatedModules = state.course.modules.map((module, mIndex) => {\n        if (mIndex === moduleIndex) {\n          const updatedContent = module.content.map((content, cIndex) => {\n            if (cIndex === contentIndex) {\n              return { ...content,\n                [fieldName]: fieldValue\n              };\n            }\n\n            return content;\n          });\n          return { ...module,\n            content: updatedContent\n          };\n        }\n\n        return module;\n      });\n      return {\n        course: {\n          modules: updatedModules\n        }\n      };\n    });\n  },\n  handleInputChange: (fieldName, fieldValue) => {\n    set(state => ({\n      course: { ...state.course,\n        [fieldName]: fieldValue\n      }\n    }));\n  }\n}));\nexport default useCourseStore;","map":{"version":3,"sources":["/home/dresito/GitHub/Trade-Learn-Frontend/src/store/store.js"],"names":["create","initialState","course","name","description","modules","useCourseStore","set","selectedOption","setCourse","newCourse","handleChangeSelect","e","moduleIndex","value","target","state","map","module","idx","updatedContents","content","type","url","text","quizData","question","answers","correctAnswer","handleAddModule","newModule","handleModuleChange","index","fieldName","fieldValue","updatedModules","handleDeleteContent","contentIndex","filter","cIdx","handleAddContent","push","existingQuizContentIndex","findIndex","handleDeleteModule","handleQuestion","questionIndex","key","updatedQuestion","handleAnswerChange","answerIndex","handleCorrectAnswerChange","handleAddQuestion","updatedContent","existingQuizIndex","handleDeleteQuestion","splice","handleContentChange","mIndex","cIndex","handleInputChange"],"mappings":"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","sourcesContent":["import create from \"zustand\"\n\nconst initialState = {\n  course: {\n    name: \"\",\n    description: \"\",\n    modules: []\n  }\n}\n\nconst useCourseStore = create((set) => ({\n  // State\n  course: initialState.course,\n  selectedOption: \"quiz\",\n\n  // Actions\n\n  setCourse: (newCourse) => set({ course: newCourse }),\n\n  handleChangeSelect: (e, moduleIndex) => {\n    const { value } = e.target;\n\n    set((state) => ({\n      selectedOption: value,\n      course: {\n        ...state.course,\n        modules: state.course.modules.map((module, idx) => {\n          if (idx === moduleIndex) {\n            let updatedContents = [];\n\n            if (module.content) {\n              updatedContents = module.content.map(content => {\n                if (content.type === value) {\n                  if (value === \"video\") {\n                    return { type: \"video\", url: \"\" };\n                  } else if (value === \"text\") {\n                    return { type: \"text\", text: \"\" };\n                  } else if (value === \"quiz\") {\n                    const quizData = {\n                      question: \"\",\n                      answers: [\"\", \"\", \"\", \"\"],\n                      correctAnswer: \"\",\n                    };\n                    return { type: \"quiz\", question: [quizData] };\n                  }\n                }\n                return content;\n              });\n            }\n\n            return {\n              ...module,\n              content: updatedContents,\n            };\n          }\n          return module;\n        }),\n      },\n    }));\n  },\n\n  handleAddModule: () => {\n    set((state) => {\n      const newModule = { name: \"\", content: [] };\n      return { course: { modules: [...state.course.modules, newModule] } };\n    });\n  },\n\n  handleModuleChange: (index, fieldName, fieldValue) => {\n    set((state) => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === index) {\n          return { ...module, [fieldName]: fieldValue };\n        }\n        return module;\n      });\n      return { course: { modules: updatedModules } };\n    });\n  },\n\n  handleDeleteContent: (moduleIndex, contentIndex) => {\n    set((state) => ({\n      course: {\n        ...state.course,\n        modules: state.course.modules.map((module, idx) => {\n          if (idx === moduleIndex) {\n            const updatedContents = module.content.filter((content, cIdx) => cIdx !== contentIndex);\n            return {\n              ...module,\n              content: updatedContents,\n            };\n          }\n          return module;\n        }),\n      },\n    }));\n  },\n\n  handleAddContent: (moduleIndex) => {\n    set((state) => ({\n      course: {\n        ...state.course,\n        modules: state.course.modules.map((module, idx) => {\n          if (idx === moduleIndex) {\n            let updatedContents = [...(module.content || [])]; // Ensure content array exists or initialize as empty array\n\n            if (state.selectedOption === \"video\") {\n              updatedContents.push({ type: \"video\", url: \"\" });\n            } else if (state.selectedOption === \"text\") {\n              updatedContents.push({ type: \"text\", text: \"\" });\n            } else if (state.selectedOption === \"quiz\") {\n              // Check if there's already a quiz content, if not, add it\n              const existingQuizContentIndex = updatedContents.findIndex(content => content.type === \"quiz\");\n              if (existingQuizContentIndex === -1) {\n                const quizData = {\n                  question: \"\",\n                  answers: [\"\", \"\", \"\", \"\"],\n                  correctAnswer: \"\",\n                };\n                updatedContents.push({ type: \"quiz\", question: [quizData] });\n              }\n            }\n\n            return {\n              ...module,\n              content: updatedContents,\n            };\n          }\n          return module;\n        }),\n      },\n    }));\n  },\n\n  handleDeleteModule: (moduleIndex) => {\n    set((state) => {\n      const updatedModules = state.course.modules.filter((module, idx) => idx !== moduleIndex);\n      return { course: { modules: updatedModules } };\n    });\n  },\n\n\n  handleQuestion: (moduleIndex, questionIndex, key, value) => {\n    set((state) => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === moduleIndex && module.content[questionIndex].type === \"quiz\") {\n          const updatedQuestion = { ...module.content[questionIndex] };\n          updatedQuestion.question = value;\n          return {\n            ...module,\n            content: module.content.map((content, cIdx) => (cIdx === questionIndex ? updatedQuestion : content)),\n          };\n        }\n        return module;\n      });\n      return { ...state, course: { ...state.course, modules: updatedModules } };\n    });\n  },\n\n  handleAnswerChange: (moduleIndex, questionIndex, answerIndex, value) => {\n    set((state) => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === moduleIndex && module.content[questionIndex].type === \"quiz\") {\n          const updatedQuestion = { ...module.content[questionIndex] };\n          updatedQuestion.answers[answerIndex] = value;\n          return {\n            ...module,\n            content: module.content.map((content, cIdx) => (cIdx === questionIndex ? updatedQuestion : content)),\n          };\n        }\n        return module;\n      });\n      return { ...state, course: { ...state.course, modules: updatedModules } };\n    });\n  },\n\n  handleCorrectAnswerChange: (moduleIndex, questionIndex, value) => {\n    set((state) => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === moduleIndex && module.content[questionIndex].type === \"quiz\") {\n          const updatedQuestion = { ...module.content[questionIndex] };\n          updatedQuestion.correctAnswer = value;\n          return {\n            ...module,\n            content: module.content.map((content, cIdx) => (cIdx === questionIndex ? updatedQuestion : content)),\n          };\n        }\n        return module;\n      });\n      return { ...state, course: { ...state.course, modules: updatedModules } };\n    });\n  },\n\n  handleAddQuestion: (moduleIndex) => {\n    set((state) => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === moduleIndex) {\n          const updatedContent = [...(module.content || [])];\n          const existingQuizIndex = updatedContent.findIndex((content) => content.type === \"quiz\");\n\n          if (existingQuizIndex !== -1) {\n            const updatedQuestion = { question: \"\", answers: [\"\", \"\", \"\", \"\"], correctAnswer: \"\" };\n            updatedContent[existingQuizIndex].question.push(updatedQuestion);\n          }\n\n          return { ...module, content: updatedContent };\n        }\n        return module;\n      });\n      return { ...state, course: { ...state.course, modules: updatedModules } };\n    });\n  },\n\n  handleDeleteQuestion: (moduleIndex, questionIndex) => {\n    set((state) => {\n      const updatedModules = state.course.modules.map((module, idx) => {\n        if (idx === moduleIndex && module.content[questionIndex].type === \"quiz\") {\n          const updatedContent = [...module.content];\n          updatedContent[questionIndex].question.splice(questionIndex, 1);\n          return { ...module, content: updatedContent };\n        }\n        return module;\n      });\n      return { ...state, course: { ...state.course, modules: updatedModules } };\n    });\n  },\n\n  handleContentChange: (moduleIndex, contentIndex, fieldName, fieldValue) => {\n    set((state) => {\n      const updatedModules = state.course.modules.map((module, mIndex) => {\n        if (mIndex === moduleIndex) {\n          const updatedContent = module.content.map((content, cIndex) => {\n            if (cIndex === contentIndex) {\n              return { ...content, [fieldName]: fieldValue };\n            }\n            return content;\n          });\n          return { ...module, content: updatedContent };\n        }\n        return module;\n      });\n      return { course: { modules: updatedModules } };\n    });\n  },\n\n  handleInputChange: (fieldName, fieldValue) => {\n    set((state) => ({\n      course: {\n        ...state.course,\n        [fieldName]: fieldValue,\n      },\n    }));\n  },\n\n}))\n\nexport default useCourseStore;"]},"metadata":{},"sourceType":"module"}